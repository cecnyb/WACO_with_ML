#include <stdint.h> 
typedef enum { COMPRESSED, UNCOMPRESSED } taco_mode_t;
typedef struct {
  int32_t      order;
  int32_t*     dimensions;
  int32_t      csize;
  int32_t*     mode_ordering;
  taco_mode_t* mode_types;
  uint8_t***   indices;
  uint8_t*     vals;
  int32_t      vals_size;
} taco_tensor_t;
// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// /home/s0/ml4sys02/project/Workload-Aware-Co-Optimization/code_generator/taco/build/bin/taco "C(i,j)=A(k1,i,k0)*B(k1,k0,j)" -f=C:dd:0,1 -f=A:ssd:0,1,2 -f=B:ddd:0,1,2 -t=C:float -t=A:float -t=B:float -write-compute=taco_kernel.c -s="bound(j,jb,256, MaxExact)" -s="bound(k0,k0b,16, MaxExact)" -s="reorder(k1,i,k0b,jb)" -s="parallelize(i,CPUThread,NoRaces)"

int compute(taco_tensor_t *C, taco_tensor_t *A, taco_tensor_t *B, taco_tensor_t *Cd, taco_tensor_t *Ad, taco_tensor_t *Bd) {
  int C1_dimension = (int)(C->dimensions[0]);
  int C2_dimension = (int)(C->dimensions[1]);
  float* __restrict C_vals = (float*)(C->vals);
  int A3_dimension = (int)(A->dimensions[2]);
  int* __restrict A1_pos = (int*)(A->indices[0][0]);
  int* __restrict A1_crd = (int*)(A->indices[0][1]);
  int* __restrict A2_pos = (int*)(A->indices[1][0]);
  int* __restrict A2_crd = (int*)(A->indices[1][1]);
  float* __restrict A_vals = (float*)(A->vals);
  int B1_dimension = (int)(B->dimensions[0]);
  int B2_dimension = (int)(B->dimensions[1]);
  int B3_dimension = (int)(B->dimensions[2]);
  float* __restrict B_vals = (float*)(B->vals);

  for (int32_t k1A = A1_pos[0]; k1A < A1_pos[1]; k1A++) {
    int32_t k1 = A1_crd[k1A];
    #pragma omp parallel for schedule(runtime)
    for (int32_t iA = A2_pos[k1A]; iA < A2_pos[(k1A + 1)]; iA++) {
      int32_t i = A2_crd[iA];
      for (int32_t k0b = 0; k0b < 16; k0b++) {
        int32_t k0A = iA * A3_dimension + k0b;
        int32_t k0B = k1 * B2_dimension + k0b;
        for (int32_t jb = 0; jb < 256; jb++) {
          int32_t jB = k0B * B3_dimension + jb;
          int32_t jC = i * C2_dimension + jb;
          C_vals[jC] = C_vals[jC] + A_vals[k0A] * B_vals[jB];
        }
      }
    }
  }
  return 0;
}
