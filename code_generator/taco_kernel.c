#include <stdint.h> 
typedef enum { COMPRESSED, UNCOMPRESSED } taco_mode_t;
typedef struct {
  int32_t      order;
  int32_t*     dimensions;
  int32_t      csize;
  int32_t*     mode_ordering;
  taco_mode_t* mode_types;
  uint8_t***   indices;
  uint8_t*     vals;
  int32_t      vals_size;
} taco_tensor_t;
// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// /home/s0/ml4sys02/project/Workload-Aware-Co-Optimization/code_generator/taco/build/bin/taco "C(i,j1,j0)=A(k1,i,k0)*B(k1,k0,j1,j0)" -f=C:ddd:0,1,2 -f=A:dsd:0,1,2 -f=B:dddd:0,1,2,3 -t=C:float -t=A:float -t=B:float -write-compute=taco_kernel.c -s="bound(j0,j0b,16, MaxExact)" -s="bound(j1,j1b,16, MaxExact)" -s="bound(k0,k0b,4, MaxExact)" -s="bound(k1,k1b,31806, MaxExact)" -s="reorder(k1b,i,k0b,j1b,j0b)" -s="parallelize(i,CPUThread,NoRaces)"

int compute(taco_tensor_t *C, taco_tensor_t *A, taco_tensor_t *B, taco_tensor_t *Cd, taco_tensor_t *Ad, taco_tensor_t *Bd) {
  int C1_dimension = (int)(C->dimensions[0]);
  int C2_dimension = (int)(C->dimensions[1]);
  int C3_dimension = (int)(C->dimensions[2]);
  float* __restrict C_vals = (float*)(C->vals);
  int A1_dimension = (int)(A->dimensions[0]);
  int A3_dimension = (int)(A->dimensions[2]);
  int* __restrict A2_pos = (int*)(A->indices[1][0]);
  int* __restrict A2_crd = (int*)(A->indices[1][1]);
  float* __restrict A_vals = (float*)(A->vals);
  int B1_dimension = (int)(B->dimensions[0]);
  int B2_dimension = (int)(B->dimensions[1]);
  int B3_dimension = (int)(B->dimensions[2]);
  int B4_dimension = (int)(B->dimensions[3]);
  float* __restrict B_vals = (float*)(B->vals);

  for (int32_t k1b = 0; k1b < 31806; k1b++) {
    #pragma omp parallel for schedule(runtime)
    for (int32_t iA = A2_pos[k1b]; iA < A2_pos[(k1b + 1)]; iA++) {
      int32_t i = A2_crd[iA];
      for (int32_t k0b = 0; k0b < 4; k0b++) {
        int32_t k0A = iA * A3_dimension + k0b;
        int32_t k0B = k1b * B2_dimension + k0b;
        for (int32_t j1b = 0; j1b < 16; j1b++) {
          int32_t j1B = k0B * B3_dimension + j1b;
          int32_t j1C = i * C2_dimension + j1b;
          for (int32_t j0b = 0; j0b < 16; j0b++) {
            int32_t j0B = j1B * B4_dimension + j0b;
            int32_t j0C = j1C * C3_dimension + j0b;
            C_vals[j0C] = C_vals[j0C] + A_vals[k0A] * B_vals[j0B];
          }
        }
      }
    }
  }
  return 0;
}
